## Use Zig after generating the project with STM32CubeMX

Details about project structure are explained in this [chapter](#Structure).
To use Zig in any microcontrollers `STM32CubeMX` generated project, with picolibc, follow these modification steps:

1. **Create a `build.zig` file** and configure it to compile the C source files (Use this one as a model).
2. **Update the target** based on the microcontroller you selected (e.g., line 7 in the `build.zig` file):

    ```zig
    const query: std.Target.Query = .{
        .cpu_arch = .thumb,
        .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m4 }, // Cortex-M4
        .cpu_features_add = std.Target.arm.featureSet(&[_]std.Target.arm.Feature{std.Target.arm.Feature.vfp4d16sp}), // Floating-point support
        .os_tag = .freestanding,
        .abi = .eabihf,
        .glibc_version = null,
    };
    ```

3. **Create the linker script** (`stm32l476rgtx_flash.ld`). This is a picolibc template that needs to be adjusted for your specific microcontrollers (e.g., RAM size, flash size, and additional sections).
4. **Copy the `libc` folder** or generate the `libc` files. Refer to the [Picolibc Integration](#Picolibc-Integration) chapter for detailed instructions.
5. **Create a `main.zig` file** with a custom entry point, such as `zigEntrypoint`.
6. **Call the `zigEntrypoint` function** from the `main` function located in the `Core/Src/main.c` file.

__Notes__

- To define additional macros in the `build.zig` file, such as enabling the LL driver, use `addCMacro("USE_LL_DRIVER", "");` for each module declared.

## Build

```bash
# Build
zig build
# Upload using stlink-tools
zig build flash
# Rmemove .zig-cache folder
zig build clean
```

## Structure

```bash
blinky_picolibc/
├── Core
│   ├── Inc
│   │   ├── gpio.h
│   │   ├── main.h
│   │   ├── stm32l4xx_hal_conf.h
│   │   ├── stm32l4xx_it.h
│   │   └── usart.h
│   └── Src
│       ├── gpio.c
│       ├── main.c
│       ├── stm32l4xx_hal_msp.c
│       ├── stm32l4xx_it.c
│       ├── system_stm32l4xx.c
│       └── usart.c
├── Drivers
├── libc
│   ├── include
│   └── lib
│       ├── picolibc.ld
│       └── picolibcpp.ld
├── src
│   ├── main.zig
│   └── vector_table.zig
├── vector_table_examples
│   ├── vector_table.c
│   └── vector_table.s
├── .vscode
├── blinky.ioc
├── build.zig
├── .clangd
├── .clang-format
├── .clang-tidy
├── .editorconfig
├── .gdbinit
├── .gitignore
├── README.md
├── stm32l476rgtx_flash.ld
└── STM32L476.svd
```

- The `Core` and `Drivers` folders were generated by STM32CubeMX software.
- **Configuration files** such as `.vscode`, `.clangd`, `.clang-format`, `.clang-tidy`, and `.editorconfig` were added for project tooling purposes.
- The file `.gdbinit` is used to debug programs that were built in a container.
- The file `STM32L476.svd` was added to enable debugging of hardware peripherals using VSCode.
- The files `build.zig`, `src/main.zig` and `src/vector_table.zig` are specific to Zig and are included for Zig-related functionality.
- The `vector_table_examples` folder contains implementations of the vector table in different programming languages (not used in the project).
- The `libc` folder contains the libc archives, headers, and linker scripts associated with picolibc.

---

## Picolibc Integration

### Prerequisite

Linux

```bash
#Install needed tool (fedora)
sudo yum install meson ninja llvm-19 clang-19 lld-19
#Install needed tool (debian)
sudo apt install meson ninja-build llvm-19 clang-19 lld-19
```
Windows

- [meson+ninja](https://github.com/mesonbuild/meson/releases/tag/1.7.0)
- [llvm19+clang](https://github.com/llvm/llvm-project/releases/tag/llvmorg-19.1.7)


### Build with container

```bash
# Create the image
podman build -f ContainerFile --tag=picolibc .
# Run a container
podman run --rm -it -v ./:/workspace --name=picolibc picolibc
# Configure
mkdir -p build/picolib && cd build/picolib
meson setup --cross-file /workspace/libc/cross-clang-thumbv7e+fp-custom.txt \
    --prefix=/workspace/libc \
    -Dtests=false \
    -Dpicocrt=true \
    -Dnewlib-global-atexit=true  \
    -Ddebug=false \
    -Doptimization=s \
    /picolibc/

# Install
ninja install
# Rename the libc (The following line is explained below)
mv /workspace/libc/lib/libc.a /workspace/libc/lib/libc_pico.a
```

### Build it with other CPU Parameters

You need to create a Meson configuration file, such as mine `cross-clang-thumbv7e+fp-custom.txt`, and modify these parameters according to your needs:

```
-mcpu=cortex-m4
-mfloat-abi=hard
-mfpu=fpv5-sp-d16
```

### Integrating the libc with Your Zig Script

If you compile your Zig program using `elf.linkSystemLibrary("c");` or if your module has the option `.link_libc = true,`, you may encounter the following error:

```bash
error: libc not available
    note: run 'zig libc -h' to learn about libc installations
    note: run 'zig targets' to see the targets for which zig can always provide libc
```

Zig does not currently allow you to customize your own libc implementation. For more details, see this [GitHub issue](https://github.com/ziglang/zig/issues/20327) discussing the topic. However, there is a workaround: you can rename the libc library and link it manually.

For example:
```bash
mv libc/lib/libc.a libc/lib/libc_pico.a
```

Then, change `elf.linkSystemLibrary("c");` to `elf.linkSystemLibrary("c_pico");`.

Now it is compile, however zig code will not benefit of libc implementation, only the `C` sources files.

### Picolibc Linker Script

Picolibc provides two linker script `picolibc.ld` and `picolibcpp.ld` that is used during the linking process. You can use it with Zig's linker (`lld`) without modification because we have build picolibc with clang/lld.
A minimal linker script for Our target is simpler:

```ld
/* This will override default value provided by picolibc */
__flash = 0x08000000;
__flash_size = 1024K;
__ram = 0x20000000;
__ram_size = 96K;
__stack_size = 512;

INCLUDE libc/lib/picolibc.ld
```

Picolibc got some options to choices for `printf` and `scanf`. You need to use `-Wl,--defsym` or `-Wl,-alias` arguments. But you can use the linker script too

```ld
/* Printf and Scanf Options. Equivalent to --defsym  */
vfprintf = __m_vfprintf; /*disable*/
vfscanf = __m_vfscanf; /*disable*/

/* Printf and Scanf Options. Equivalent to -alias */
/* PROVIDE(vfprintf = __m_vfprintf); */
/* PROVIDE(vfscanf = __m_vfscanf); */
```

**Adapt the linker script from STM32CubeMX**

Target linker script now can just specify flash memory option, extra section and so on. See the new linker script `stm32l476rgtx_flash.ld` that add information about the second ram section `.ram2` and set formatting options.


### Update the startup and the Vector Table

I created my own startup file `vector_table.zig` with modifications for picolibc integration. You can see the assembler and C implementations under the folder `vector_table_examples`. Here is what needs to be changed from the original file `startup_stm32l476xx.s`:

1. Rename `g_pfnVectors` to `__interrupt_vector`. The reference can be used by picolibc
2. Rename `isr_vector` section to `.text.init.enter`
3. Rename stack start  `_estack`  by `__stack`
4. Rename the entrypoint  `Reset_Handler` to `_start` in the `__interrupt_vector` table
5. Remove the `Reset_Handler` and `LoopForever` function.
6. Remove symbol `_sidata`, `_sdata`, `_edata`, `_sbss`, `_ebss`

---

You can note that the instruction `ldr   sp, =__stack` is not used anymore . This instruction is used by ARM architecture to initialize the stack pointer.
For STM32 microcontrollers (and many other ARM Cortex-M-based microcontrollers), the stack pointer is automatically initialized by the hardware using a specific memory address defined in the vector table (here `0x08000000`)

I don’t know exactly why this instruction is in the template (it might be for historical or compatibility reasons), but you can remove it without any issues.
One example where it might be needed is when you have a bootloader and your starting address changes (e.g., `0x08010000`). However, in such cases, you would typically set the new vector table before jumping to the application in the bootloader.

## Notes

- Main article about this picolibc implementation: [Ziggit topic](https://ziggit.dev/t/adding-picolibc-for-embedded-stm32-example/8421)
- For an interesting discussion on integrating Picolibc or alternative libc implementations for embedded systems, check out this [Ziggit topic](https://ziggit.dev/t/adding-picolibc-or-alternative-for-embedded/).
- For more context on integrating custom libc implementations, see this [GitHub issue](https://github.com/ziglang/zig/issues/20327).
- Effort to make compatible Zig with meson build system. [GitHub issue](https://github.com/mesonbuild/meson/issues/12652)



